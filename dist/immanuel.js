(()=>{"use strict";eval("\n// UNUSED EXPORTS: default\n\n// CONCATENATED MODULE: ./src/options.js\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar options_Options = /*#__PURE__*/function () {\n  function Options() {\n    _classCallCheck(this, Options);\n  }\n\n  _createClass(Options, null, [{\n    key: \"create\",\n    value: function create(options) {\n      return _objectSpread(_objectSpread({}, this.defaults), options);\n    }\n  }]);\n\n  return Options;\n}();\n\noptions_Options.defaults = {\n  rotateToHorizon: true,\n  rotateSigns: true,\n  rotateHouseNumbers: false,\n  rotateAngleText: false,\n  angleFormat: '%D&deg;%M\\'',\n  lineOrder: ['houses', 'angleMarkers', 'anglePointers', 'aspects'],\n  aspectOrder: ['trine', 'sextile', 'semisextile', 'square', 'semisquare', 'sesquisquare', 'opposite', 'quintile', 'semiquintile', 'sesquiquintile', 'biquintile', 'quincunx']\n};\n\n// CONCATENATED MODULE: ./src/elements.js\nfunction elements_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction elements_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction elements_createClass(Constructor, protoProps, staticProps) { if (protoProps) elements_defineProperties(Constructor.prototype, protoProps); if (staticProps) elements_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar elements_Elements = /*#__PURE__*/function () {\n  elements_createClass(Elements, null, [{\n    key: \"create\",\n    value: function create(selector) {\n      return this.instance || (this.instance = new this(selector));\n    }\n  }]);\n\n  function Elements(selector) {\n    elements_classCallCheck(this, Elements);\n\n    // Main chart container\n    this.chart = document.querySelector(selector);\n\n    if (!this.chart) {\n      return false;\n    } // Container, boundaries & tracks provided by the user\n\n\n    this.chartSvgContainer = this.chart.querySelector('[data-immanuel-lines]');\n    this.chartBackground = this.chart.querySelector('[data-immanuel-background]');\n    this.angleTrack = this.chart.querySelector('[data-immanuel-track=\"angles\"]');\n    this.signTrack = this.chart.querySelector('[data-immanuel-track=\"signs\"]');\n    this.planetTrack = this.chart.querySelector('[data-immanuel-track=\"planets\"]');\n    this.angleTextTrack = this.chart.querySelector('[data-immanuel-track=\"angle-text\"]');\n    this.houseNumberTrack = this.chart.querySelector('[data-immanuel-track=\"house-numbers\"]');\n    this.houseStartBoundary = this.chart.querySelector('[data-immanuel-boundary=\"house-start\"]');\n    this.houseEndBoundary = this.chart.querySelector('[data-immanuel-boundary=\"house-end\"]');\n    this.angleMarkersStartBoundary = this.chart.querySelector('[data-immanuel-boundary=\"angle-markers-start\"]');\n    this.angleMarkersEndBoundary = this.chart.querySelector('[data-immanuel-boundary=\"angle-markers-end\"]');\n    this.aspectEndBoundary = this.chart.querySelector('[data-immanuel-boundary=\"aspect-end\"]'); // Chart elements provided by users\n\n    this.angles = this.chart.querySelectorAll('[data-immanuel-angle]');\n    this.signs = this.chart.querySelectorAll('[data-immanuel-sign]');\n    this.planets = this.chart.querySelectorAll('[data-immanuel-planet]');\n    this.placeholders = this.chart.querySelectorAll('[data-immanuel-placeholder]'); // Create extra elements the chart will need\n\n    this.chartLines = [];\n    this.houseNumbers = [];\n    this.angleText = {};\n\n    if (this.houseNumberTrack) {\n      this.createHouseNumberElements();\n    }\n\n    if (this.angleTextTrack) {\n      this.createAngleTextElements();\n    }\n\n    if (this.markerTrack) {\n      this.createInnerMarkerTrackElement();\n    }\n\n    this.createSvgElement();\n  } // SVG element for drawing lines\n\n\n  elements_createClass(Elements, [{\n    key: \"createSvgElement\",\n    value: function createSvgElement() {\n      this.chartSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n      this.chartSvg.setAttributeNS(null, 'width', '100%');\n      this.chartSvg.setAttributeNS(null, 'height', '100%');\n      Object.assign(this.chartSvg.style, {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%'\n      });\n\n      if (this.chartSvgContainer) {\n        this.chartSvgContainer.appendChild(this.chartSvg);\n      } else {\n        this.chart.appendChild(this.chartSvg);\n      }\n    } // Set up house numbers\n\n  }, {\n    key: \"createHouseNumberElements\",\n    value: function createHouseNumberElements() {\n      for (var i = 1; i <= 12; ++i) {\n        var houseNumberElement = document.createElement('span');\n        houseNumberElement.textContent = i;\n        houseNumberElement.style.position = 'absolute';\n        houseNumberElement.classList.add('immanuel__house-number', \"house-number--\".concat(i));\n        this.houseNumbers[i] = houseNumberElement;\n        this.chart.appendChild(houseNumberElement);\n      }\n    } // Create elements to display each planet's angle\n\n  }, {\n    key: \"createAngleTextElements\",\n    value: function createAngleTextElements() {\n      var _this = this;\n\n      this.planets.forEach(function (planetElement) {\n        var planetName = planetElement.getAttribute('data-immanuel-planet');\n        var planetClassName = planetName.replace(' ', '-');\n        var angleTextElement = document.createElement('div');\n        angleTextElement.classList.add('immanuel__angle-text', \"angle-text--\".concat(planetClassName));\n        angleTextElement.style.position = 'absolute';\n        _this.angleText[planetName] = angleTextElement;\n\n        _this.chart.appendChild(angleTextElement);\n      });\n    }\n  }]);\n\n  return Elements;\n}();\n\nelements_Elements.instance = null;\n\n// CONCATENATED MODULE: ./src/chart.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction chart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction chart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction chart_createClass(Constructor, protoProps, staticProps) { if (protoProps) chart_defineProperties(Constructor.prototype, protoProps); if (staticProps) chart_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar chart_Chart = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  chart_createClass(Chart, null, [{\n    key: \"create\",\n    value: function create(elements, options, chartData) {\n      return new this(elements, options, chartData);\n    }\n  }]);\n\n  function Chart(elements, options, chartData) {\n    chart_classCallCheck(this, Chart);\n\n    this.elements = elements;\n    this.options = options;\n    this.chartData = chartData;\n    this.offsetAngle = 0;\n    this.planets = {};\n    this.aspectedPlanets = [];\n    this.init();\n  } // Set things up ready for drawing the chart.\n\n\n  chart_createClass(Chart, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      // Collate all wanted planets regardless of type into the same map for simplicity\n      this.elements.planets.forEach(function (planetElement) {\n        var planetName = planetElement.getAttribute('data-immanuel-planet'); // Find it\n\n        if (planetName in _this.chartData.points) {\n          var planet = _this.chartData.points[planetName];\n        } else if (planetName in _this.chartData.planets) {\n          var planet = _this.chartData.planets[planetName];\n        } // Store it\n\n\n        _this.planets[planetName] = planet; // Store which aspects we want to draw\n\n        if (!planetElement.hasAttribute('data-immanuel-no-aspects')) {\n          _this.aspectedPlanets.push(planetName);\n        }\n      }); // Ensure everything is redrawn on resize\n\n      window.addEventListener('resize', function () {\n        document.querySelectorAll('[data-immanuel-hide]').length || _this.setupChart();\n      });\n    } // Set up the chart elements & display them.\n\n  }, {\n    key: \"display\",\n    value: function display() {\n      var _this2 = this;\n\n      // Only attempt to set up display if all elements are loaded\n      if (document.readyState !== 'complete') {\n        window.addEventListener('load', function () {\n          _this2.display();\n        });\n        return;\n      }\n\n      this.setOffsetAngle();\n      this.rotateChart();\n\n      if (this.elements.placeholders) {\n        this.setPlaceholderData();\n      }\n\n      this.setupChart(); // Now unhide it\n\n      document.querySelectorAll('[data-immanuel-hide]').forEach(function (element) {\n        element.removeAttribute('data-immanuel-hide');\n      });\n    } // Calculate the offset for all subsequent angles based on rotating the chart to the horizon line.\n\n  }, {\n    key: \"setOffsetAngle\",\n    value: function setOffsetAngle() {\n      this.offsetAngle = this.options.rotateToHorizon ? this.chartData.angles.asc.chartAngle - 180 : 0;\n    } // Rotate the chart visual to the horizon line.\n\n  }, {\n    key: \"rotateChart\",\n    value: function rotateChart() {\n      this.elements.chartBackground.style.transform = this.offsetAngle > 0 ? \"rotate(\".concat(this.offsetAngle, \"deg)\") : 'none';\n    } // If any placeholders exist for available data, populate them.\n\n  }, {\n    key: \"setPlaceholderData\",\n    value: function setPlaceholderData() {\n      var _this3 = this;\n\n      this.elements.placeholders.forEach(function (placeholderElement) {\n        var angleType = placeholderElement.getAttribute('data-immanuel-placeholder');\n\n        switch (angleType) {\n          case 'asc':\n          case 'desc':\n          case 'mc':\n          case 'ic':\n            placeholderElement.innerHTML = Utils.formatAngleString(_this3.chartData.angles[angleType].formattedSignAngle, _this3.options.angleFormat);\n            break;\n        }\n      });\n    } // Set up all the chart's dynamic elements.\n\n  }, {\n    key: \"setupChart\",\n    value: function setupChart() {\n      // Set up HTML elements\n      if (this.elements.angleTrack && this.elements.angles) {\n        this.setAngles();\n      }\n\n      if (this.elements.signTrack && this.elements.signs) {\n        this.setSigns();\n      }\n\n      if (this.elements.planetTrack && this.elements.planets) {\n        this.setPlanets();\n      } // Refresh all drawn lines - this must be called after setPlanets()\n      // since the angle marker lines need the corrected position of each planet.\n\n\n      this.removeLines();\n      this.drawLines();\n    } // Remove chart lines for redrawing.\n\n  }, {\n    key: \"removeLines\",\n    value: function removeLines() {\n      this.elements.chartLines.forEach(function (chartLine) {\n        chartLine.remove();\n      });\n    } // Draw all SVG lines in the requested order.\n\n  }, {\n    key: \"drawLines\",\n    value: function drawLines() {\n      var _this4 = this;\n\n      this.options.lineOrder.reverse().forEach(function (lineType) {\n        switch (lineType) {\n          case 'angleMarkers':\n            if (_this4.elements.angleMarkersStartBoundary && _this4.elements.angleMarkersEndBoundary) {\n              _this4.setPlanetAngleMarkers();\n            }\n\n            break;\n\n          case 'anglePointers':\n            if (_this4.elements.angleMarkersStartBoundary) {\n              _this4.setPlanetAnglePointers();\n            }\n\n            break;\n\n          case 'houses':\n            if (_this4.elements.houseStartBoundary && _this4.elements.houseEndBoundary) {\n              _this4.setHouses();\n\n              if (_this4.elements.houseNumberTrack) {\n                _this4.setHouseNumbers();\n              }\n            }\n\n            break;\n\n          case 'aspects':\n            _this4.setAspects();\n\n            break;\n        }\n      });\n    } // Position the ASC / MC etc. angle labels\n\n  }, {\n    key: \"setAngles\",\n    value: function setAngles() {\n      var _this5 = this;\n\n      this.elements.angles.forEach(function (angleElement) {\n        var angleName = angleElement.getAttribute('data-immanuel-angle');\n        var angle = _this5.chartData.angles[angleName].chartAngle - _this5.offsetAngle;\n\n        var _Utils$findRelativePo = Utils.findRelativePoint(_this5.elements.angleTrack, angle),\n            _Utils$findRelativePo2 = _slicedToArray(_Utils$findRelativePo, 2),\n            x = _Utils$findRelativePo2[0],\n            y = _Utils$findRelativePo2[1];\n\n        x = Math.round(x - angleElement.offsetWidth / 2);\n        y = Math.round(y - angleElement.offsetHeight / 2);\n        Object.assign(angleElement.style, {\n          position: 'absolute',\n          left: x + 'px',\n          top: y + 'px'\n        });\n      });\n    } // Position the sign elements if they exist.\n\n  }, {\n    key: \"setSigns\",\n    value: function setSigns() {\n      var _this6 = this;\n\n      var signAngle = 15 - this.offsetAngle;\n      this.elements.signs.forEach(function (signElement) {\n        var _Utils$findRelativePo3 = Utils.findRelativePoint(_this6.elements.signTrack, signAngle),\n            _Utils$findRelativePo4 = _slicedToArray(_Utils$findRelativePo3, 2),\n            x = _Utils$findRelativePo4[0],\n            y = _Utils$findRelativePo4[1];\n\n        x = Math.round(x - signElement.offsetWidth / 2);\n        y = Math.round(y - signElement.offsetHeight / 2);\n        Object.assign(signElement.style, {\n          position: 'absolute',\n          left: x + 'px',\n          top: y + 'px'\n        });\n\n        if (_this6.options.rotateSigns) {\n          var rotationAngle = signAngle * -1 + 90;\n          signElement.style.transform = \"rotate(\".concat(rotationAngle, \"deg)\");\n        }\n\n        signAngle += 30;\n      });\n    } // Set up the planets & their angles.\n\n  }, {\n    key: \"setPlanets\",\n    value: function setPlanets() {\n      this.resetPlanetAngles();\n      this.resolvePlanetCollisions();\n      this.positionPlanets();\n\n      if (this.elements.angleTextTrack) {\n        this.setPlanetAngleText();\n      }\n    } // Reset planet angles to their potentially colliding defaults for resize.\n\n  }, {\n    key: \"resetPlanetAngles\",\n    value: function resetPlanetAngles() {\n      Object.values(this.planets).forEach(function (planet) {\n        planet.displayAngle = planet.chartAngle;\n      });\n    } // Space out planets when they collide with each other.\n\n  }, {\n    key: \"resolvePlanetCollisions\",\n    value: function resolvePlanetCollisions() {\n      var _this7 = this;\n\n      // Form groups of colliding planets\n      var collisionGroups = [];\n      this.elements.planets.forEach(function (planetElement) {\n        var planetName = planetElement.getAttribute('data-immanuel-planet');\n        var planet = _this7.planets[planetName]; // For each planet, check whether it's colliding with another planet\n\n        _this7.elements.planets.forEach(function (testPlanetElement) {\n          var testPlanetName = testPlanetElement.getAttribute('data-immanuel-planet');\n\n          if (planetName === testPlanetName) {\n            return;\n          } // Test for collision here by checking for the gap between their centres being less than their combined radii\n\n\n          var testPlanet = _this7.planets[testPlanetName];\n          var planetRadius = Math.max(planetElement.offsetWidth, planetElement.offsetHeight) / 2;\n          var testPlanetRadius = Math.max(testPlanetElement.offsetWidth, testPlanetElement.offsetHeight) / 2;\n          var trackDiameter = _this7.elements.planetTrack.offsetWidth;\n          var degreesBetween = Math.abs(planet.displayAngle - testPlanet.displayAngle);\n          var gapBetween = Math.abs(Math.sin(degreesBetween * (Math.PI / 360)) * trackDiameter); // If we have a collision, add it to a collision group, which is an array\n          // containing all the planets involved in this collision (eg. a stellium)\n\n          if (gapBetween < planetRadius + testPlanetRadius) {\n            collisionGroups.forEach(function (collisionGroup) {\n              if (collisionGroup.includes(planet) || collisionGroup.includes(testPlanet)) {\n                if (!collisionGroup.includes(planet)) {\n                  collisionGroup.push(planet);\n                }\n\n                if (!collisionGroup.includes(testPlanet)) {\n                  collisionGroup.push(testPlanet);\n                }\n\n                return;\n              }\n            });\n            collisionGroups.push([planet, testPlanet]);\n          }\n        });\n      }); // Now we loop over all collision groups and space them out evenly before recursing to recalculate\n      // If the angle between planets > 270 degrees we assume one of them is crossing the zero point\n\n      if (collisionGroups.length > 0) {\n        collisionGroups.forEach(function (collisionGroup) {\n          collisionGroup.sort(function (a, b) {\n            return Math.abs(a.displayAngle - b.displayAngle) > 270 ? b.displayAngle - a.displayAngle : a.displayAngle - b.displayAngle;\n          });\n          collisionGroup[0].displayAngle -= 0.1;\n          collisionGroup[collisionGroup.length - 1].displayAngle += 0.1;\n        });\n        this.resolvePlanetCollisions();\n      }\n    } // Position the planet elements.\n\n  }, {\n    key: \"positionPlanets\",\n    value: function positionPlanets() {\n      var _this8 = this;\n\n      this.elements.planets.forEach(function (planetElement) {\n        var planetName = planetElement.getAttribute('data-immanuel-planet');\n        var planet = _this8.planets[planetName];\n        var angle = planet.displayAngle - _this8.offsetAngle;\n        var movement = planet.movement.toLowerCase(); // Add classes for planet movement & sign\n\n        planetElement.classList.add('immanuel__planet-movement', \"planet-movement--\".concat(movement));\n        planetElement.classList.add('immanuel__planet-sign', \"planet-sign--\".concat(planet.sign.toLowerCase())); // Position the planet\n\n        var _Utils$findRelativePo5 = Utils.findRelativePoint(_this8.elements.planetTrack, angle),\n            _Utils$findRelativePo6 = _slicedToArray(_Utils$findRelativePo5, 2),\n            x = _Utils$findRelativePo6[0],\n            y = _Utils$findRelativePo6[1];\n\n        x = Math.round(x - planetElement.offsetWidth / 2);\n        y = Math.round(y - planetElement.offsetHeight / 2);\n        Object.assign(planetElement.style, {\n          position: 'absolute',\n          left: x + 'px',\n          top: y + 'px'\n        });\n      });\n    } // Add angle text for each planet.\n\n  }, {\n    key: \"setPlanetAngleText\",\n    value: function setPlanetAngleText() {\n      for (var _i2 = 0, _Object$entries = Object.entries(this.planets); _i2 < _Object$entries.length; _i2++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n            planetName = _Object$entries$_i[0],\n            planet = _Object$entries$_i[1];\n\n        var angle = planet.displayAngle - this.offsetAngle;\n        var angleTextElement = this.elements.angleText[planetName]; // Add angle text & reset any previous rotation\n\n        angleTextElement.style.transform = 'none';\n        angleTextElement.innerHTML = Utils.formatAngleString(planet.formattedSignAngle, this.options.angleFormat); // Rotate & offset position if requested\n\n        if (this.options.rotateAngleText) {\n          var leftOffset = angleTextElement.offsetWidth / 2;\n          var topOffset = angleTextElement.offsetHeight / 2;\n          var rotationAngle = angle * -1;\n\n          if (angle > 90 && angle < 270) {\n            rotationAngle -= 180;\n          }\n\n          angleTextElement.style.transform = \"rotate(\".concat(rotationAngle, \"deg)\");\n        } else {\n          var _Utils$findRelativePo7 = Utils.findRelativePoint(this.elements.chart, angle),\n              _Utils$findRelativePo8 = _slicedToArray(_Utils$findRelativePo7, 2),\n              relX = _Utils$findRelativePo8[0],\n              relY = _Utils$findRelativePo8[1];\n\n          var leftOffset = angleTextElement.offsetWidth * (relX / this.elements.chart.offsetWidth);\n          var topOffset = angleTextElement.offsetHeight * (relY / this.elements.chart.offsetHeight);\n        } // Set position based on calculated offsets\n\n\n        var _Utils$findGlobalPoin = Utils.findGlobalPoint(this.elements.chart, this.elements.angleTextTrack, angle),\n            _Utils$findGlobalPoin2 = _slicedToArray(_Utils$findGlobalPoin, 2),\n            absX = _Utils$findGlobalPoin2[0],\n            absY = _Utils$findGlobalPoin2[1];\n\n        absX = Math.round(absX - leftOffset);\n        absY = Math.round(absY - topOffset);\n        Object.assign(angleTextElement.style, {\n          left: absX + 'px',\n          top: absY + 'px'\n        });\n      }\n    } // Add the markers for each planet's original pre-collision-check placement.\n\n  }, {\n    key: \"setPlanetAngleMarkers\",\n    value: function setPlanetAngleMarkers() {\n      for (var _i3 = 0, _Object$entries2 = Object.entries(this.planets); _i3 < _Object$entries2.length; _i3++) {\n        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2),\n            planetName = _Object$entries2$_i[0],\n            planet = _Object$entries2$_i[1];\n\n        var angle = planet.chartAngle - this.offsetAngle;\n        var planetClassName = planetName.replace(' ', '-');\n\n        var _Utils$findGlobalPoin3 = Utils.findGlobalPoint(this.elements.chart, this.elements.angleMarkersEndBoundary, angle),\n            _Utils$findGlobalPoin4 = _slicedToArray(_Utils$findGlobalPoin3, 2),\n            x1 = _Utils$findGlobalPoin4[0],\n            y1 = _Utils$findGlobalPoin4[1];\n\n        var _Utils$findGlobalPoin5 = Utils.findGlobalPoint(this.elements.chart, this.elements.angleMarkersStartBoundary, angle),\n            _Utils$findGlobalPoin6 = _slicedToArray(_Utils$findGlobalPoin5, 2),\n            x2 = _Utils$findGlobalPoin6[0],\n            y2 = _Utils$findGlobalPoin6[1];\n\n        this.drawLine(x1, y1, x2, y2, 'immanuel__angle-marker', \"angle-marker--\".concat(planetClassName));\n      }\n    } // Add lines from each angle marker to the planet's actual position.\n\n  }, {\n    key: \"setPlanetAnglePointers\",\n    value: function setPlanetAnglePointers() {\n      var _this9 = this;\n\n      this.elements.planets.forEach(function (planetElement) {\n        var planetName = planetElement.getAttribute('data-immanuel-planet');\n        var planet = _this9.planets[planetName];\n        var markerAngle = planet.chartAngle - _this9.offsetAngle;\n        var planetAngle = planet.displayAngle - _this9.offsetAngle;\n        var planetDiameter = Math.max(planetElement.offsetWidth, planetElement.offsetHeight);\n        var planetClassName = planetName.replace(' ', '-');\n\n        var _Utils$findGlobalPoin7 = Utils.findGlobalPoint(_this9.elements.chart, _this9.elements.angleMarkersStartBoundary, markerAngle),\n            _Utils$findGlobalPoin8 = _slicedToArray(_Utils$findGlobalPoin7, 2),\n            x1 = _Utils$findGlobalPoin8[0],\n            y1 = _Utils$findGlobalPoin8[1];\n\n        var _Utils$findGlobalPoin9 = Utils.findGlobalPoint(_this9.elements.chart, _this9.elements.planetTrack, planetAngle, planetDiameter + 10),\n            _Utils$findGlobalPoin10 = _slicedToArray(_Utils$findGlobalPoin9, 2),\n            x2 = _Utils$findGlobalPoin10[0],\n            y2 = _Utils$findGlobalPoin10[1];\n\n        var _Utils$findGlobalPoin11 = Utils.findGlobalPoint(_this9.elements.chart, _this9.elements.planetTrack, planetAngle, planetDiameter),\n            _Utils$findGlobalPoin12 = _slicedToArray(_Utils$findGlobalPoin11, 2),\n            x3 = _Utils$findGlobalPoin12[0],\n            y3 = _Utils$findGlobalPoin12[1];\n\n        _this9.drawLine(x1, y1, x2, y2, 'immanuel__angle-pointer', \"angle-pointer--\".concat(planetClassName));\n\n        _this9.drawLine(x2, y2, x3, y3, 'immanuel__angle-pointer', \"angle-pointer--\".concat(planetClassName));\n      });\n    } // Draw the house cusp lines.\n\n  }, {\n    key: \"setHouses\",\n    value: function setHouses() {\n      for (var _i4 = 0, _Object$entries3 = Object.entries(this.chartData.houses); _i4 < _Object$entries3.length; _i4++) {\n        var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i4], 2),\n            houseNumber = _Object$entries3$_i[0],\n            house = _Object$entries3$_i[1];\n\n        var angle = house.chartAngle - this.offsetAngle;\n\n        var _Utils$findGlobalPoin13 = Utils.findGlobalPoint(this.elements.chart, this.elements.houseEndBoundary, angle),\n            _Utils$findGlobalPoin14 = _slicedToArray(_Utils$findGlobalPoin13, 2),\n            x1 = _Utils$findGlobalPoin14[0],\n            y1 = _Utils$findGlobalPoin14[1];\n\n        var _Utils$findGlobalPoin15 = Utils.findGlobalPoint(this.elements.chart, this.elements.houseStartBoundary, angle),\n            _Utils$findGlobalPoin16 = _slicedToArray(_Utils$findGlobalPoin15, 2),\n            x2 = _Utils$findGlobalPoin16[0],\n            y2 = _Utils$findGlobalPoin16[1];\n\n        this.drawLine(x1, y1, x2, y2, 'immanuel__house-line', \"house-line--\".concat(houseNumber));\n      }\n    } // Add house numbers\n\n  }, {\n    key: \"setHouseNumbers\",\n    value: function setHouseNumbers() {\n      for (var _i5 = 0, _Object$entries4 = Object.entries(this.chartData.houses); _i5 < _Object$entries4.length; _i5++) {\n        var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i5], 2),\n            houseNumber = _Object$entries4$_i[0],\n            house = _Object$entries4$_i[1];\n\n        var angle = house.chartAngle - this.offsetAngle;\n        var nextHouseNumber = houseNumber == 12 ? 1 : parseInt(houseNumber) + 1;\n        var nextHouseAngle = this.chartData.houses[nextHouseNumber].chartAngle;\n        var houseWidthAngle = (nextHouseAngle < angle ? nextHouseAngle + 360 : nextHouseAngle) - angle;\n        var midpointAngle = angle + (houseWidthAngle - this.offsetAngle) / 2;\n        var houseNumberElement = this.elements.houseNumbers[houseNumber];\n\n        var _Utils$findGlobalPoin17 = Utils.findGlobalPoint(this.elements.chart, this.elements.houseNumberTrack, midpointAngle),\n            _Utils$findGlobalPoin18 = _slicedToArray(_Utils$findGlobalPoin17, 2),\n            x = _Utils$findGlobalPoin18[0],\n            y = _Utils$findGlobalPoin18[1];\n\n        x = Math.round(x - houseNumberElement.offsetWidth / 2);\n        y = Math.round(y - houseNumberElement.offsetHeight / 2);\n        Object.assign(houseNumberElement.style, {\n          left: x + 'px',\n          top: y + 'px'\n        });\n\n        if (this.options.rotateHouseNumbers) {\n          var rotationAngle = midpointAngle * -1 + 90;\n          houseNumberElement.style.transform = \"rotate(\".concat(rotationAngle, \"deg)\");\n        }\n      }\n    } // Draw aspect lines in the order the types are laid out in this.options.aspectOrder.\n\n  }, {\n    key: \"setAspects\",\n    value: function setAspects() {\n      var _this10 = this;\n\n      var aspectsToDraw = {};\n      this.options.aspectOrder.reverse().forEach(function (aspectType) {\n        return aspectsToDraw[aspectType] = [];\n      });\n\n      for (var _i6 = 0, _Object$entries5 = Object.entries(this.planets); _i6 < _Object$entries5.length; _i6++) {\n        var _Object$entries5$_i = _slicedToArray(_Object$entries5[_i6], 2),\n            planetName = _Object$entries5$_i[0],\n            planet = _Object$entries5$_i[1];\n\n        var _loop = function _loop() {\n          var _Object$entries6$_i = _slicedToArray(_Object$entries6[_i7], 2),\n              aspectedPlanetName = _Object$entries6$_i[0],\n              aspect = _Object$entries6$_i[1];\n\n          var _sort = [planetName, aspectedPlanetName].sort(),\n              _sort2 = _slicedToArray(_sort, 2),\n              startPlanetName = _sort2[0],\n              endPlanetName = _sort2[1];\n\n          var aspectType = aspect.type.toLowerCase(); // If this is an planet we don't want to aspect, or this is an aspect we don't want, skip it\n\n          if (!_this10.aspectedPlanets.includes(startPlanetName) || !_this10.aspectedPlanets.includes(endPlanetName) || !_this10.options.aspectOrder.includes(aspectType)) {\n            return \"continue\";\n          }\n\n          var aspectToDraw = {\n            startAngle: _this10.planets[startPlanetName].chartAngle - _this10.offsetAngle,\n            endAngle: _this10.planets[endPlanetName].chartAngle - _this10.offsetAngle\n          }; // Avoid duplicates\n\n          if (aspectsToDraw[aspectType].some(function (aspectData) {\n            return JSON.stringify(aspectData) === JSON.stringify(aspectToDraw);\n          })) {\n            return \"continue\";\n          }\n\n          aspectsToDraw[aspectType].push(aspectToDraw);\n        };\n\n        for (var _i7 = 0, _Object$entries6 = Object.entries(planet.aspects); _i7 < _Object$entries6.length; _i7++) {\n          var _ret = _loop();\n\n          if (_ret === \"continue\") continue;\n        }\n      } // Now we have our definitive list, draw them\n\n\n      var _loop2 = function _loop2() {\n        var _Object$entries7$_i = _slicedToArray(_Object$entries7[_i8], 2),\n            aspectType = _Object$entries7$_i[0],\n            aspectList = _Object$entries7$_i[1];\n\n        aspectList.forEach(function (aspect) {\n          var _Utils$findGlobalPoin19 = Utils.findGlobalPoint(_this10.elements.chart, _this10.elements.aspectEndBoundary, aspect.startAngle),\n              _Utils$findGlobalPoin20 = _slicedToArray(_Utils$findGlobalPoin19, 2),\n              x1 = _Utils$findGlobalPoin20[0],\n              y1 = _Utils$findGlobalPoin20[1];\n\n          var _Utils$findGlobalPoin21 = Utils.findGlobalPoint(_this10.elements.chart, _this10.elements.aspectEndBoundary, aspect.endAngle),\n              _Utils$findGlobalPoin22 = _slicedToArray(_Utils$findGlobalPoin21, 2),\n              x2 = _Utils$findGlobalPoin22[0],\n              y2 = _Utils$findGlobalPoin22[1];\n\n          _this10.drawLine(x1, y1, x2, y2, 'immanuel__aspect-line', \"aspect-line--\".concat(aspectType));\n        });\n      };\n\n      for (var _i8 = 0, _Object$entries7 = Object.entries(aspectsToDraw); _i8 < _Object$entries7.length; _i8++) {\n        _loop2();\n      }\n    } // Draw a line in the chart based on coordinates, and add classes.\n\n  }, {\n    key: \"drawLine\",\n    value: function drawLine(x1, y1, x2, y2) {\n      var _line$classList;\n\n      var line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n\n      for (var _len = arguments.length, classList = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n        classList[_key - 4] = arguments[_key];\n      }\n\n      (_line$classList = line.classList).add.apply(_line$classList, classList);\n\n      line.setAttributeNS(null, 'x1', x1);\n      line.setAttributeNS(null, 'y1', y1);\n      line.setAttributeNS(null, 'x2', x2);\n      line.setAttributeNS(null, 'y2', y2);\n      this.elements.chartSvg.appendChild(line);\n      this.elements.chartLines.push(line);\n    }\n  }]);\n\n  return Chart;\n}()));\n\n\n// CONCATENATED MODULE: ./src/immanuel.js\nfunction immanuel_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction immanuel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { immanuel_ownKeys(Object(source), true).forEach(function (key) { immanuel_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { immanuel_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction immanuel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction immanuel_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction immanuel_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction immanuel_createClass(Constructor, protoProps, staticProps) { if (protoProps) immanuel_defineProperties(Constructor.prototype, protoProps); if (staticProps) immanuel_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar Immanuel = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  function Immanuel(selector) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    immanuel_classCallCheck(this, Immanuel);\n\n    this.elements = Elements.create(selector);\n    this.options = Options.create(options);\n  }\n\n  immanuel_createClass(Immanuel, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = immanuel_objectSpread(immanuel_objectSpread({}, this.options), options);\n    }\n  }, {\n    key: \"displayChart\",\n    value: function displayChart(chartData) {\n      Chart.create(this.elements, this.options, chartData).display();\n    }\n  }]);\n\n  return Immanuel;\n}()));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbW1hbnVlbC8uL3NyYy9vcHRpb25zLmpzPzRjNmIiLCJ3ZWJwYWNrOi8vaW1tYW51ZWwvLi9zcmMvZWxlbWVudHMuanM/OWRmMCIsIndlYnBhY2s6Ly9pbW1hbnVlbC8uL3NyYy9jaGFydC5qcz84NTFmIiwid2VicGFjazovL2ltbWFudWVsLy4vc3JjL2ltbWFudWVsLmpzPzY4ODkiXSwibmFtZXMiOlsiT3B0aW9ucyIsIm9wdGlvbnMiLCJkZWZhdWx0cyIsInJvdGF0ZVRvSG9yaXpvbiIsInJvdGF0ZVNpZ25zIiwicm90YXRlSG91c2VOdW1iZXJzIiwicm90YXRlQW5nbGVUZXh0IiwiYW5nbGVGb3JtYXQiLCJsaW5lT3JkZXIiLCJhc3BlY3RPcmRlciIsIkVsZW1lbnRzIiwic2VsZWN0b3IiLCJpbnN0YW5jZSIsImNoYXJ0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiY2hhcnRTdmdDb250YWluZXIiLCJjaGFydEJhY2tncm91bmQiLCJhbmdsZVRyYWNrIiwic2lnblRyYWNrIiwicGxhbmV0VHJhY2siLCJhbmdsZVRleHRUcmFjayIsImhvdXNlTnVtYmVyVHJhY2siLCJob3VzZVN0YXJ0Qm91bmRhcnkiLCJob3VzZUVuZEJvdW5kYXJ5IiwiYW5nbGVNYXJrZXJzU3RhcnRCb3VuZGFyeSIsImFuZ2xlTWFya2Vyc0VuZEJvdW5kYXJ5IiwiYXNwZWN0RW5kQm91bmRhcnkiLCJhbmdsZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwic2lnbnMiLCJwbGFuZXRzIiwicGxhY2Vob2xkZXJzIiwiY2hhcnRMaW5lcyIsImhvdXNlTnVtYmVycyIsImFuZ2xlVGV4dCIsImNyZWF0ZUhvdXNlTnVtYmVyRWxlbWVudHMiLCJjcmVhdGVBbmdsZVRleHRFbGVtZW50cyIsIm1hcmtlclRyYWNrIiwiY3JlYXRlSW5uZXJNYXJrZXJUcmFja0VsZW1lbnQiLCJjcmVhdGVTdmdFbGVtZW50IiwiY2hhcnRTdmciLCJjcmVhdGVFbGVtZW50TlMiLCJzZXRBdHRyaWJ1dGVOUyIsIk9iamVjdCIsImFzc2lnbiIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJhcHBlbmRDaGlsZCIsImkiLCJob3VzZU51bWJlckVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidGV4dENvbnRlbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJmb3JFYWNoIiwicGxhbmV0RWxlbWVudCIsInBsYW5ldE5hbWUiLCJnZXRBdHRyaWJ1dGUiLCJwbGFuZXRDbGFzc05hbWUiLCJyZXBsYWNlIiwiYW5nbGVUZXh0RWxlbWVudCIsIkNoYXJ0IiwiZWxlbWVudHMiLCJjaGFydERhdGEiLCJvZmZzZXRBbmdsZSIsImFzcGVjdGVkUGxhbmV0cyIsImluaXQiLCJwb2ludHMiLCJwbGFuZXQiLCJoYXNBdHRyaWJ1dGUiLCJwdXNoIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImxlbmd0aCIsInNldHVwQ2hhcnQiLCJyZWFkeVN0YXRlIiwiZGlzcGxheSIsInNldE9mZnNldEFuZ2xlIiwicm90YXRlQ2hhcnQiLCJzZXRQbGFjZWhvbGRlckRhdGEiLCJlbGVtZW50IiwicmVtb3ZlQXR0cmlidXRlIiwiYXNjIiwiY2hhcnRBbmdsZSIsInRyYW5zZm9ybSIsInBsYWNlaG9sZGVyRWxlbWVudCIsImFuZ2xlVHlwZSIsImlubmVySFRNTCIsIlV0aWxzIiwiZm9ybWF0QW5nbGVTdHJpbmciLCJmb3JtYXR0ZWRTaWduQW5nbGUiLCJzZXRBbmdsZXMiLCJzZXRTaWducyIsInNldFBsYW5ldHMiLCJyZW1vdmVMaW5lcyIsImRyYXdMaW5lcyIsImNoYXJ0TGluZSIsInJlbW92ZSIsInJldmVyc2UiLCJsaW5lVHlwZSIsInNldFBsYW5ldEFuZ2xlTWFya2VycyIsInNldFBsYW5ldEFuZ2xlUG9pbnRlcnMiLCJzZXRIb3VzZXMiLCJzZXRIb3VzZU51bWJlcnMiLCJzZXRBc3BlY3RzIiwiYW5nbGVFbGVtZW50IiwiYW5nbGVOYW1lIiwiYW5nbGUiLCJmaW5kUmVsYXRpdmVQb2ludCIsIngiLCJ5IiwiTWF0aCIsInJvdW5kIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJzaWduQW5nbGUiLCJzaWduRWxlbWVudCIsInJvdGF0aW9uQW5nbGUiLCJyZXNldFBsYW5ldEFuZ2xlcyIsInJlc29sdmVQbGFuZXRDb2xsaXNpb25zIiwicG9zaXRpb25QbGFuZXRzIiwic2V0UGxhbmV0QW5nbGVUZXh0IiwidmFsdWVzIiwiZGlzcGxheUFuZ2xlIiwiY29sbGlzaW9uR3JvdXBzIiwidGVzdFBsYW5ldEVsZW1lbnQiLCJ0ZXN0UGxhbmV0TmFtZSIsInRlc3RQbGFuZXQiLCJwbGFuZXRSYWRpdXMiLCJtYXgiLCJ0ZXN0UGxhbmV0UmFkaXVzIiwidHJhY2tEaWFtZXRlciIsImRlZ3JlZXNCZXR3ZWVuIiwiYWJzIiwiZ2FwQmV0d2VlbiIsInNpbiIsIlBJIiwiY29sbGlzaW9uR3JvdXAiLCJpbmNsdWRlcyIsInNvcnQiLCJhIiwiYiIsIm1vdmVtZW50IiwidG9Mb3dlckNhc2UiLCJzaWduIiwiZW50cmllcyIsImxlZnRPZmZzZXQiLCJ0b3BPZmZzZXQiLCJyZWxYIiwicmVsWSIsImZpbmRHbG9iYWxQb2ludCIsImFic1giLCJhYnNZIiwieDEiLCJ5MSIsIngyIiwieTIiLCJkcmF3TGluZSIsIm1hcmtlckFuZ2xlIiwicGxhbmV0QW5nbGUiLCJwbGFuZXREaWFtZXRlciIsIngzIiwieTMiLCJob3VzZXMiLCJob3VzZU51bWJlciIsImhvdXNlIiwibmV4dEhvdXNlTnVtYmVyIiwicGFyc2VJbnQiLCJuZXh0SG91c2VBbmdsZSIsImhvdXNlV2lkdGhBbmdsZSIsIm1pZHBvaW50QW5nbGUiLCJhc3BlY3RzVG9EcmF3IiwiYXNwZWN0VHlwZSIsImFzcGVjdGVkUGxhbmV0TmFtZSIsImFzcGVjdCIsInN0YXJ0UGxhbmV0TmFtZSIsImVuZFBsYW5ldE5hbWUiLCJ0eXBlIiwiYXNwZWN0VG9EcmF3Iiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwic29tZSIsImFzcGVjdERhdGEiLCJKU09OIiwic3Ry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QnZMLFFBQWhCLENBQWhCO0FBQ0EsU0FBS1YsT0FBTCxHQUFlRCxPQUFPLENBQUNrTSxNQUFSLENBQWVqTSxPQUFmLENBQWY7QUFDSDs7OzsrQkFFVUEsTyxFQUFTO0FBQ2hCLFdBQUtBLE9BQUwsbURBQ08sS0FBS0EsT0FEWixHQUVPQSxPQUZQO0FBSUg7OztpQ0FFWW1FLFMsRUFBVztBQUNwQkYsV0FBSyxDQUFDZ0ksTUFBTixDQUFhLEtBQUsvSCxRQUFsQixFQUE0QixLQUFLbEUsT0FBakMsRUFBMENtRSxTQUExQyxFQUFxRGEsT0FBckQ7QUFDSCIsImZpbGUiOiI2NzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBPcHRpb25zIHtcblxuICAgIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAgICAgcm90YXRlVG9Ib3Jpem9uOiB0cnVlLFxuICAgICAgICByb3RhdGVTaWduczogdHJ1ZSxcbiAgICAgICAgcm90YXRlSG91c2VOdW1iZXJzOiBmYWxzZSxcbiAgICAgICAgcm90YXRlQW5nbGVUZXh0OiBmYWxzZSxcbiAgICAgICAgYW5nbGVGb3JtYXQ6ICclRCZkZWc7JU1cXCcnLFxuICAgICAgICBsaW5lT3JkZXI6IFtcbiAgICAgICAgICAgICdob3VzZXMnLFxuICAgICAgICAgICAgJ2FuZ2xlTWFya2VycycsXG4gICAgICAgICAgICAnYW5nbGVQb2ludGVycycsXG4gICAgICAgICAgICAnYXNwZWN0cycsXG4gICAgICAgIF0sXG4gICAgICAgIGFzcGVjdE9yZGVyOiBbXG4gICAgICAgICAgICAndHJpbmUnLFxuICAgICAgICAgICAgJ3NleHRpbGUnLFxuICAgICAgICAgICAgJ3NlbWlzZXh0aWxlJyxcbiAgICAgICAgICAgICdzcXVhcmUnLFxuICAgICAgICAgICAgJ3NlbWlzcXVhcmUnLFxuICAgICAgICAgICAgJ3Nlc3F1aXNxdWFyZScsXG4gICAgICAgICAgICAnb3Bwb3NpdGUnLFxuICAgICAgICAgICAgJ3F1aW50aWxlJyxcbiAgICAgICAgICAgICdzZW1pcXVpbnRpbGUnLFxuICAgICAgICAgICAgJ3Nlc3F1aXF1aW50aWxlJyxcbiAgICAgICAgICAgICdiaXF1aW50aWxlJyxcbiAgICAgICAgICAgICdxdWluY3VueCdcbiAgICAgICAgXSxcbiAgICB9O1xuXG4gICAgc3RhdGljIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLmRlZmF1bHRzLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICB9XG5cbn0iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50cyB7XG5cbiAgICBzdGF0aWMgaW5zdGFuY2UgPSBudWxsO1xuXG4gICAgc3RhdGljIGNyZWF0ZShzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZSB8fCAodGhpcy5pbnN0YW5jZSA9IG5ldyB0aGlzKHNlbGVjdG9yKSk7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgLy8gTWFpbiBjaGFydCBjb250YWluZXJcbiAgICAgICAgdGhpcy5jaGFydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuXG4gICAgICAgIGlmICghdGhpcy5jaGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udGFpbmVyLCBib3VuZGFyaWVzICYgdHJhY2tzIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4gICAgICAgIHRoaXMuY2hhcnRTdmdDb250YWluZXIgPSB0aGlzLmNoYXJ0LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWltbWFudWVsLWxpbmVzXScpO1xuICAgICAgICB0aGlzLmNoYXJ0QmFja2dyb3VuZCA9IHRoaXMuY2hhcnQucXVlcnlTZWxlY3RvcignW2RhdGEtaW1tYW51ZWwtYmFja2dyb3VuZF0nKTtcbiAgICAgICAgdGhpcy5hbmdsZVRyYWNrID0gdGhpcy5jaGFydC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pbW1hbnVlbC10cmFjaz1cImFuZ2xlc1wiXScpO1xuICAgICAgICB0aGlzLnNpZ25UcmFjayA9IHRoaXMuY2hhcnQucXVlcnlTZWxlY3RvcignW2RhdGEtaW1tYW51ZWwtdHJhY2s9XCJzaWduc1wiXScpO1xuICAgICAgICB0aGlzLnBsYW5ldFRyYWNrID0gdGhpcy5jaGFydC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pbW1hbnVlbC10cmFjaz1cInBsYW5ldHNcIl0nKTtcbiAgICAgICAgdGhpcy5hbmdsZVRleHRUcmFjayA9IHRoaXMuY2hhcnQucXVlcnlTZWxlY3RvcignW2RhdGEtaW1tYW51ZWwtdHJhY2s9XCJhbmdsZS10ZXh0XCJdJyk7XG4gICAgICAgIHRoaXMuaG91c2VOdW1iZXJUcmFjayA9IHRoaXMuY2hhcnQucXVlcnlTZWxlY3RvcignW2RhdGEtaW1tYW51ZWwtdHJhY2s9XCJob3VzZS1udW1iZXJzXCJdJyk7XG4gICAgICAgIHRoaXMuaG91c2VTdGFydEJvdW5kYXJ5ID0gdGhpcy5jaGFydC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pbW1hbnVlbC1ib3VuZGFyeT1cImhvdXNlLXN0YXJ0XCJdJyk7XG4gICAgICAgIHRoaXMuaG91c2VFbmRCb3VuZGFyeSA9IHRoaXMuY2hhcnQucXVlcnlTZWxlY3RvcignW2RhdGEtaW1tYW51ZWwtYm91bmRhcnk9XCJob3VzZS1lbmRcIl0nKTtcbiAgICAgICAgdGhpcy5hbmdsZU1hcmtlcnNTdGFydEJvdW5kYXJ5ID0gdGhpcy5jaGFydC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pbW1hbnVlbC1ib3VuZGFyeT1cImFuZ2xlLW1hcmtlcnMtc3RhcnRcIl0nKTtcbiAgICAgICAgdGhpcy5hbmdsZU1hcmtlcnNFbmRCb3VuZGFyeSA9IHRoaXMuY2hhcnQucXVlcnlTZWxlY3RvcignW2RhdGEtaW1tYW51ZWwtYm91bmRhcnk9XCJhbmdsZS1tYXJrZXJzLWVuZFwiXScpO1xuICAgICAgICB0aGlzLmFzcGVjdEVuZEJvdW5kYXJ5ID0gdGhpcy5jaGFydC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pbW1hbnVlbC1ib3VuZGFyeT1cImFzcGVjdC1lbmRcIl0nKTtcblxuICAgICAgICAvLyBDaGFydCBlbGVtZW50cyBwcm92aWRlZCBieSB1c2Vyc1xuICAgICAgICB0aGlzLmFuZ2xlcyA9IHRoaXMuY2hhcnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtaW1tYW51ZWwtYW5nbGVdJyk7XG4gICAgICAgIHRoaXMuc2lnbnMgPSB0aGlzLmNoYXJ0LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWltbWFudWVsLXNpZ25dJyk7XG4gICAgICAgIHRoaXMucGxhbmV0cyA9IHRoaXMuY2hhcnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtaW1tYW51ZWwtcGxhbmV0XScpO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVycyA9IHRoaXMuY2hhcnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtaW1tYW51ZWwtcGxhY2Vob2xkZXJdJyk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGV4dHJhIGVsZW1lbnRzIHRoZSBjaGFydCB3aWxsIG5lZWRcbiAgICAgICAgdGhpcy5jaGFydExpbmVzID0gW107XG4gICAgICAgIHRoaXMuaG91c2VOdW1iZXJzID0gW107XG4gICAgICAgIHRoaXMuYW5nbGVUZXh0ID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuaG91c2VOdW1iZXJUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVIb3VzZU51bWJlckVsZW1lbnRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbmdsZVRleHRUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVBbmdsZVRleHRFbGVtZW50cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFya2VyVHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlSW5uZXJNYXJrZXJUcmFja0VsZW1lbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3JlYXRlU3ZnRWxlbWVudCgpO1xuICAgIH1cblxuICAgIC8vIFNWRyBlbGVtZW50IGZvciBkcmF3aW5nIGxpbmVzXG4gICAgY3JlYXRlU3ZnRWxlbWVudCgpIHtcbiAgICAgICAgdGhpcy5jaGFydFN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gICAgICAgIHRoaXMuY2hhcnRTdmcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgJzEwMCUnKTtcbiAgICAgICAgdGhpcy5jaGFydFN2Zy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0JywgJzEwMCUnKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY2hhcnRTdmcuc3R5bGUsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2hhcnRTdmdDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhcnRTdmdDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jaGFydFN2Zyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoYXJ0LmFwcGVuZENoaWxkKHRoaXMuY2hhcnRTdmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IHVwIGhvdXNlIG51bWJlcnNcbiAgICBjcmVhdGVIb3VzZU51bWJlckVsZW1lbnRzKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSAxMjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBob3VzZU51bWJlckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBob3VzZU51bWJlckVsZW1lbnQudGV4dENvbnRlbnQgPSBpO1xuICAgICAgICAgICAgaG91c2VOdW1iZXJFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIGhvdXNlTnVtYmVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdpbW1hbnVlbF9faG91c2UtbnVtYmVyJywgYGhvdXNlLW51bWJlci0tJHtpfWApO1xuICAgICAgICAgICAgdGhpcy5ob3VzZU51bWJlcnNbaV0gPSBob3VzZU51bWJlckVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmNoYXJ0LmFwcGVuZENoaWxkKGhvdXNlTnVtYmVyRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgZWxlbWVudHMgdG8gZGlzcGxheSBlYWNoIHBsYW5ldCdzIGFuZ2xlXG4gICAgY3JlYXRlQW5nbGVUZXh0RWxlbWVudHMoKSB7XG4gICAgICAgIHRoaXMucGxhbmV0cy5mb3JFYWNoKHBsYW5ldEVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGxhbmV0TmFtZSA9IHBsYW5ldEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWltbWFudWVsLXBsYW5ldCcpO1xuICAgICAgICAgICAgY29uc3QgcGxhbmV0Q2xhc3NOYW1lID0gcGxhbmV0TmFtZS5yZXBsYWNlKCcgJywgJy0nKTtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlVGV4dEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGFuZ2xlVGV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaW1tYW51ZWxfX2FuZ2xlLXRleHQnLCBgYW5nbGUtdGV4dC0tJHtwbGFuZXRDbGFzc05hbWV9YCk7XG4gICAgICAgICAgICBhbmdsZVRleHRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIHRoaXMuYW5nbGVUZXh0W3BsYW5ldE5hbWVdID0gYW5nbGVUZXh0RWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuY2hhcnQuYXBwZW5kQ2hpbGQoYW5nbGVUZXh0RWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxufSIsImltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhcnQge1xuXG4gICAgc3RhdGljIGNyZWF0ZShlbGVtZW50cywgb3B0aW9ucywgY2hhcnREYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhlbGVtZW50cywgb3B0aW9ucywgY2hhcnREYXRhKTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cywgb3B0aW9ucywgY2hhcnREYXRhKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jaGFydERhdGEgPSBjaGFydERhdGE7XG4gICAgICAgIHRoaXMub2Zmc2V0QW5nbGUgPSAwO1xuICAgICAgICB0aGlzLnBsYW5ldHMgPSB7fTtcbiAgICAgICAgdGhpcy5hc3BlY3RlZFBsYW5ldHMgPSBbXTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoaW5ncyB1cCByZWFkeSBmb3IgZHJhd2luZyB0aGUgY2hhcnQuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgLy8gQ29sbGF0ZSBhbGwgd2FudGVkIHBsYW5ldHMgcmVnYXJkbGVzcyBvZiB0eXBlIGludG8gdGhlIHNhbWUgbWFwIGZvciBzaW1wbGljaXR5XG4gICAgICAgIHRoaXMuZWxlbWVudHMucGxhbmV0cy5mb3JFYWNoKHBsYW5ldEVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGxhbmV0TmFtZSA9IHBsYW5ldEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWltbWFudWVsLXBsYW5ldCcpO1xuXG4gICAgICAgICAgICAvLyBGaW5kIGl0XG4gICAgICAgICAgICBpZiAocGxhbmV0TmFtZSBpbiB0aGlzLmNoYXJ0RGF0YS5wb2ludHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGxhbmV0ID0gdGhpcy5jaGFydERhdGEucG9pbnRzW3BsYW5ldE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGxhbmV0TmFtZSBpbiB0aGlzLmNoYXJ0RGF0YS5wbGFuZXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsYW5ldCA9IHRoaXMuY2hhcnREYXRhLnBsYW5ldHNbcGxhbmV0TmFtZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIGl0XG4gICAgICAgICAgICB0aGlzLnBsYW5ldHNbcGxhbmV0TmFtZV0gPSBwbGFuZXQ7XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHdoaWNoIGFzcGVjdHMgd2Ugd2FudCB0byBkcmF3XG4gICAgICAgICAgICBpZiAoIXBsYW5ldEVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLWltbWFudWVsLW5vLWFzcGVjdHMnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNwZWN0ZWRQbGFuZXRzLnB1c2gocGxhbmV0TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEVuc3VyZSBldmVyeXRoaW5nIGlzIHJlZHJhd24gb24gcmVzaXplXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWltbWFudWVsLWhpZGVdJykubGVuZ3RoIHx8IHRoaXMuc2V0dXBDaGFydCgpOyB9KTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgdGhlIGNoYXJ0IGVsZW1lbnRzICYgZGlzcGxheSB0aGVtLlxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIC8vIE9ubHkgYXR0ZW1wdCB0byBzZXQgdXAgZGlzcGxheSBpZiBhbGwgZWxlbWVudHMgYXJlIGxvYWRlZFxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7IHRoaXMuZGlzcGxheSgpOyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0T2Zmc2V0QW5nbGUoKTtcbiAgICAgICAgdGhpcy5yb3RhdGVDaGFydCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLnBsYWNlaG9sZGVycykge1xuICAgICAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlckRhdGEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0dXBDaGFydCgpO1xuXG4gICAgICAgIC8vIE5vdyB1bmhpZGUgaXRcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtaW1tYW51ZWwtaGlkZV0nKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaW1tYW51ZWwtaGlkZScpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIG9mZnNldCBmb3IgYWxsIHN1YnNlcXVlbnQgYW5nbGVzIGJhc2VkIG9uIHJvdGF0aW5nIHRoZSBjaGFydCB0byB0aGUgaG9yaXpvbiBsaW5lLlxuICAgIHNldE9mZnNldEFuZ2xlKCkge1xuICAgICAgICB0aGlzLm9mZnNldEFuZ2xlID0gdGhpcy5vcHRpb25zLnJvdGF0ZVRvSG9yaXpvbiA/IHRoaXMuY2hhcnREYXRhLmFuZ2xlcy5hc2MuY2hhcnRBbmdsZSAtIDE4MCA6IDA7XG4gICAgfVxuXG4gICAgLy8gUm90YXRlIHRoZSBjaGFydCB2aXN1YWwgdG8gdGhlIGhvcml6b24gbGluZS5cbiAgICByb3RhdGVDaGFydCgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5jaGFydEJhY2tncm91bmQuc3R5bGUudHJhbnNmb3JtID0gdGhpcy5vZmZzZXRBbmdsZSA+IDAgPyBgcm90YXRlKCR7dGhpcy5vZmZzZXRBbmdsZX1kZWcpYCA6ICdub25lJztcbiAgICB9XG5cbiAgICAvLyBJZiBhbnkgcGxhY2Vob2xkZXJzIGV4aXN0IGZvciBhdmFpbGFibGUgZGF0YSwgcG9wdWxhdGUgdGhlbS5cbiAgICBzZXRQbGFjZWhvbGRlckRhdGEoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMucGxhY2Vob2xkZXJzLmZvckVhY2gocGxhY2Vob2xkZXJFbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlVHlwZSA9IHBsYWNlaG9sZGVyRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW1tYW51ZWwtcGxhY2Vob2xkZXInKTtcblxuICAgICAgICAgICAgc3dpdGNoIChhbmdsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhc2MnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rlc2MnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21jJzpcbiAgICAgICAgICAgICAgICBjYXNlICdpYyc6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyRWxlbWVudC5pbm5lckhUTUwgPSBVdGlscy5mb3JtYXRBbmdsZVN0cmluZyh0aGlzLmNoYXJ0RGF0YS5hbmdsZXNbYW5nbGVUeXBlXS5mb3JtYXR0ZWRTaWduQW5nbGUsIHRoaXMub3B0aW9ucy5hbmdsZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgYWxsIHRoZSBjaGFydCdzIGR5bmFtaWMgZWxlbWVudHMuXG4gICAgc2V0dXBDaGFydCgpIHtcbiAgICAgICAgLy8gU2V0IHVwIEhUTUwgZWxlbWVudHNcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMuYW5nbGVUcmFjayAmJiB0aGlzLmVsZW1lbnRzLmFuZ2xlcykge1xuICAgICAgICAgICAgdGhpcy5zZXRBbmdsZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLnNpZ25UcmFjayAmJiB0aGlzLmVsZW1lbnRzLnNpZ25zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNpZ25zKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5lbGVtZW50cy5wbGFuZXRUcmFjayAmJiB0aGlzLmVsZW1lbnRzLnBsYW5ldHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGxhbmV0cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVmcmVzaCBhbGwgZHJhd24gbGluZXMgLSB0aGlzIG11c3QgYmUgY2FsbGVkIGFmdGVyIHNldFBsYW5ldHMoKVxuICAgICAgICAvLyBzaW5jZSB0aGUgYW5nbGUgbWFya2VyIGxpbmVzIG5lZWQgdGhlIGNvcnJlY3RlZCBwb3NpdGlvbiBvZiBlYWNoIHBsYW5ldC5cbiAgICAgICAgdGhpcy5yZW1vdmVMaW5lcygpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lcygpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBjaGFydCBsaW5lcyBmb3IgcmVkcmF3aW5nLlxuICAgIHJlbW92ZUxpbmVzKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzLmNoYXJ0TGluZXMuZm9yRWFjaChjaGFydExpbmUgPT4ge1xuICAgICAgICAgICAgY2hhcnRMaW5lLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEcmF3IGFsbCBTVkcgbGluZXMgaW4gdGhlIHJlcXVlc3RlZCBvcmRlci5cbiAgICBkcmF3TGluZXMoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5saW5lT3JkZXIucmV2ZXJzZSgpLmZvckVhY2gobGluZVR5cGUgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChsaW5lVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FuZ2xlTWFya2Vycyc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLmFuZ2xlTWFya2Vyc1N0YXJ0Qm91bmRhcnkgJiYgdGhpcy5lbGVtZW50cy5hbmdsZU1hcmtlcnNFbmRCb3VuZGFyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQbGFuZXRBbmdsZU1hcmtlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2FuZ2xlUG9pbnRlcnMnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50cy5hbmdsZU1hcmtlcnNTdGFydEJvdW5kYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBsYW5ldEFuZ2xlUG9pbnRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXNlcyc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLmhvdXNlU3RhcnRCb3VuZGFyeSAmJiB0aGlzLmVsZW1lbnRzLmhvdXNlRW5kQm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SG91c2VzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzLmhvdXNlTnVtYmVyVHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEhvdXNlTnVtYmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYXNwZWN0cyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXNwZWN0cygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUG9zaXRpb24gdGhlIEFTQyAvIE1DIGV0Yy4gYW5nbGUgbGFiZWxzXG4gICAgc2V0QW5nbGVzKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzLmFuZ2xlcy5mb3JFYWNoKGFuZ2xlRWxlbWVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbmdsZU5hbWUgPSBhbmdsZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWltbWFudWVsLWFuZ2xlJyk7XG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9IHRoaXMuY2hhcnREYXRhLmFuZ2xlc1thbmdsZU5hbWVdLmNoYXJ0QW5nbGUgLSB0aGlzLm9mZnNldEFuZ2xlO1xuXG4gICAgICAgICAgICBsZXQgW3gsIHldID0gVXRpbHMuZmluZFJlbGF0aXZlUG9pbnQodGhpcy5lbGVtZW50cy5hbmdsZVRyYWNrLCBhbmdsZSk7XG5cbiAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKHggLSBhbmdsZUVsZW1lbnQub2Zmc2V0V2lkdGggLyAyKTtcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKHkgLSBhbmdsZUVsZW1lbnQub2Zmc2V0SGVpZ2h0IC8gMik7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYW5nbGVFbGVtZW50LnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgbGVmdDogeCArICdweCcsXG4gICAgICAgICAgICAgICAgdG9wOiB5ICsgJ3B4JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQb3NpdGlvbiB0aGUgc2lnbiBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LlxuICAgIHNldFNpZ25zKCkge1xuICAgICAgICBsZXQgc2lnbkFuZ2xlID0gMTUgLSB0aGlzLm9mZnNldEFuZ2xlO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudHMuc2lnbnMuZm9yRWFjaChzaWduRWxlbWVudCA9PiB7XG4gICAgICAgICAgICBsZXQgW3gsIHldID0gVXRpbHMuZmluZFJlbGF0aXZlUG9pbnQodGhpcy5lbGVtZW50cy5zaWduVHJhY2ssIHNpZ25BbmdsZSk7XG5cbiAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKHggLSBzaWduRWxlbWVudC5vZmZzZXRXaWR0aCAvIDIpO1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoeSAtIHNpZ25FbGVtZW50Lm9mZnNldEhlaWdodCAvIDIpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHNpZ25FbGVtZW50LnN0eWxlLCB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgbGVmdDogeCArICdweCcsXG4gICAgICAgICAgICAgICAgdG9wOiB5ICsgJ3B4JyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJvdGF0ZVNpZ25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm90YXRpb25BbmdsZSA9IChzaWduQW5nbGUgKiAtMSkgKyA5MDtcbiAgICAgICAgICAgICAgICBzaWduRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgcm90YXRlKCR7cm90YXRpb25BbmdsZX1kZWcpYDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2lnbkFuZ2xlICs9IDMwO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgdGhlIHBsYW5ldHMgJiB0aGVpciBhbmdsZXMuXG4gICAgc2V0UGxhbmV0cygpIHtcbiAgICAgICAgdGhpcy5yZXNldFBsYW5ldEFuZ2xlcygpO1xuICAgICAgICB0aGlzLnJlc29sdmVQbGFuZXRDb2xsaXNpb25zKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25QbGFuZXRzKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMuYW5nbGVUZXh0VHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGxhbmV0QW5nbGVUZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNldCBwbGFuZXQgYW5nbGVzIHRvIHRoZWlyIHBvdGVudGlhbGx5IGNvbGxpZGluZyBkZWZhdWx0cyBmb3IgcmVzaXplLlxuICAgIHJlc2V0UGxhbmV0QW5nbGVzKCkge1xuICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMucGxhbmV0cykuZm9yRWFjaChwbGFuZXQgPT4ge1xuICAgICAgICAgICAgcGxhbmV0LmRpc3BsYXlBbmdsZSA9IHBsYW5ldC5jaGFydEFuZ2xlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTcGFjZSBvdXQgcGxhbmV0cyB3aGVuIHRoZXkgY29sbGlkZSB3aXRoIGVhY2ggb3RoZXIuXG4gICAgcmVzb2x2ZVBsYW5ldENvbGxpc2lvbnMoKSB7XG4gICAgICAgIC8vIEZvcm0gZ3JvdXBzIG9mIGNvbGxpZGluZyBwbGFuZXRzXG4gICAgICAgIGNvbnN0IGNvbGxpc2lvbkdyb3VwcyA9IFtdO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudHMucGxhbmV0cy5mb3JFYWNoKHBsYW5ldEVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGxhbmV0TmFtZSA9IHBsYW5ldEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWltbWFudWVsLXBsYW5ldCcpO1xuICAgICAgICAgICAgY29uc3QgcGxhbmV0ID0gdGhpcy5wbGFuZXRzW3BsYW5ldE5hbWVdO1xuXG4gICAgICAgICAgICAvLyBGb3IgZWFjaCBwbGFuZXQsIGNoZWNrIHdoZXRoZXIgaXQncyBjb2xsaWRpbmcgd2l0aCBhbm90aGVyIHBsYW5ldFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5wbGFuZXRzLmZvckVhY2godGVzdFBsYW5ldEVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RQbGFuZXROYW1lID0gdGVzdFBsYW5ldEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWltbWFudWVsLXBsYW5ldCcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBsYW5ldE5hbWUgPT09IHRlc3RQbGFuZXROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUZXN0IGZvciBjb2xsaXNpb24gaGVyZSBieSBjaGVja2luZyBmb3IgdGhlIGdhcCBiZXR3ZWVuIHRoZWlyIGNlbnRyZXMgYmVpbmcgbGVzcyB0aGFuIHRoZWlyIGNvbWJpbmVkIHJhZGlpXG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdFBsYW5ldCA9IHRoaXMucGxhbmV0c1t0ZXN0UGxhbmV0TmFtZV07XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhbmV0UmFkaXVzID0gTWF0aC5tYXgocGxhbmV0RWxlbWVudC5vZmZzZXRXaWR0aCwgcGxhbmV0RWxlbWVudC5vZmZzZXRIZWlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0UGxhbmV0UmFkaXVzID0gTWF0aC5tYXgodGVzdFBsYW5ldEVsZW1lbnQub2Zmc2V0V2lkdGgsIHRlc3RQbGFuZXRFbGVtZW50Lm9mZnNldEhlaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrRGlhbWV0ZXIgPSB0aGlzLmVsZW1lbnRzLnBsYW5ldFRyYWNrLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZ3JlZXNCZXR3ZWVuID0gTWF0aC5hYnMocGxhbmV0LmRpc3BsYXlBbmdsZSAtIHRlc3RQbGFuZXQuZGlzcGxheUFuZ2xlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXBCZXR3ZWVuID0gTWF0aC5hYnMoTWF0aC5zaW4oZGVncmVlc0JldHdlZW4gKiAoTWF0aC5QSSAvIDM2MCkpICogdHJhY2tEaWFtZXRlcik7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgY29sbGlzaW9uLCBhZGQgaXQgdG8gYSBjb2xsaXNpb24gZ3JvdXAsIHdoaWNoIGlzIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgLy8gY29udGFpbmluZyBhbGwgdGhlIHBsYW5ldHMgaW52b2x2ZWQgaW4gdGhpcyBjb2xsaXNpb24gKGVnLiBhIHN0ZWxsaXVtKVxuICAgICAgICAgICAgICAgIGlmIChnYXBCZXR3ZWVuIDwgcGxhbmV0UmFkaXVzICsgdGVzdFBsYW5ldFJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25Hcm91cHMuZm9yRWFjaChjb2xsaXNpb25Hcm91cCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uR3JvdXAuaW5jbHVkZXMocGxhbmV0KSB8fCBjb2xsaXNpb25Hcm91cC5pbmNsdWRlcyh0ZXN0UGxhbmV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sbGlzaW9uR3JvdXAuaW5jbHVkZXMocGxhbmV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25Hcm91cC5wdXNoKHBsYW5ldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2xsaXNpb25Hcm91cC5pbmNsdWRlcyh0ZXN0UGxhbmV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25Hcm91cC5wdXNoKHRlc3RQbGFuZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uR3JvdXBzLnB1c2goW3BsYW5ldCwgdGVzdFBsYW5ldF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBOb3cgd2UgbG9vcCBvdmVyIGFsbCBjb2xsaXNpb24gZ3JvdXBzIGFuZCBzcGFjZSB0aGVtIG91dCBldmVubHkgYmVmb3JlIHJlY3Vyc2luZyB0byByZWNhbGN1bGF0ZVxuICAgICAgICAvLyBJZiB0aGUgYW5nbGUgYmV0d2VlbiBwbGFuZXRzID4gMjcwIGRlZ3JlZXMgd2UgYXNzdW1lIG9uZSBvZiB0aGVtIGlzIGNyb3NzaW5nIHRoZSB6ZXJvIHBvaW50XG4gICAgICAgIGlmIChjb2xsaXNpb25Hcm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29sbGlzaW9uR3JvdXBzLmZvckVhY2goY29sbGlzaW9uR3JvdXAgPT4ge1xuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkdyb3VwLnNvcnQoKGEsIGIpID0+IE1hdGguYWJzKGEuZGlzcGxheUFuZ2xlIC0gYi5kaXNwbGF5QW5nbGUpID4gMjcwID8gYi5kaXNwbGF5QW5nbGUgLSBhLmRpc3BsYXlBbmdsZSA6IGEuZGlzcGxheUFuZ2xlIC0gYi5kaXNwbGF5QW5nbGUpO1xuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkdyb3VwWzBdLmRpc3BsYXlBbmdsZSAtPSAwLjE7XG4gICAgICAgICAgICAgICAgY29sbGlzaW9uR3JvdXBbY29sbGlzaW9uR3JvdXAubGVuZ3RoLTFdLmRpc3BsYXlBbmdsZSArPSAwLjE7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlUGxhbmV0Q29sbGlzaW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUG9zaXRpb24gdGhlIHBsYW5ldCBlbGVtZW50cy5cbiAgICBwb3NpdGlvblBsYW5ldHMoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMucGxhbmV0cy5mb3JFYWNoKHBsYW5ldEVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGxhbmV0TmFtZSA9IHBsYW5ldEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWltbWFudWVsLXBsYW5ldCcpO1xuICAgICAgICAgICAgY29uc3QgcGxhbmV0ID0gdGhpcy5wbGFuZXRzW3BsYW5ldE5hbWVdO1xuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBwbGFuZXQuZGlzcGxheUFuZ2xlIC0gdGhpcy5vZmZzZXRBbmdsZTtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVtZW50ID0gcGxhbmV0Lm1vdmVtZW50LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBjbGFzc2VzIGZvciBwbGFuZXQgbW92ZW1lbnQgJiBzaWduXG4gICAgICAgICAgICBwbGFuZXRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ltbWFudWVsX19wbGFuZXQtbW92ZW1lbnQnLCBgcGxhbmV0LW1vdmVtZW50LS0ke21vdmVtZW50fWApO1xuICAgICAgICAgICAgcGxhbmV0RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdpbW1hbnVlbF9fcGxhbmV0LXNpZ24nLCBgcGxhbmV0LXNpZ24tLSR7cGxhbmV0LnNpZ24udG9Mb3dlckNhc2UoKX1gKTtcblxuICAgICAgICAgICAgLy8gUG9zaXRpb24gdGhlIHBsYW5ldFxuICAgICAgICAgICAgbGV0IFt4LCB5XSA9IFV0aWxzLmZpbmRSZWxhdGl2ZVBvaW50KHRoaXMuZWxlbWVudHMucGxhbmV0VHJhY2ssIGFuZ2xlKTtcblxuICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoeCAtIHBsYW5ldEVsZW1lbnQub2Zmc2V0V2lkdGggLyAyKTtcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKHkgLSBwbGFuZXRFbGVtZW50Lm9mZnNldEhlaWdodCAvIDIpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHBsYW5ldEVsZW1lbnQuc3R5bGUsIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiB4ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB0b3A6IHkgKyAncHgnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbmdsZSB0ZXh0IGZvciBlYWNoIHBsYW5ldC5cbiAgICBzZXRQbGFuZXRBbmdsZVRleHQoKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3BsYW5ldE5hbWUsIHBsYW5ldF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5wbGFuZXRzKSkge1xuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBwbGFuZXQuZGlzcGxheUFuZ2xlIC0gdGhpcy5vZmZzZXRBbmdsZTtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlVGV4dEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzLmFuZ2xlVGV4dFtwbGFuZXROYW1lXTtcblxuICAgICAgICAgICAgLy8gQWRkIGFuZ2xlIHRleHQgJiByZXNldCBhbnkgcHJldmlvdXMgcm90YXRpb25cbiAgICAgICAgICAgIGFuZ2xlVGV4dEVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgICAgICAgYW5nbGVUZXh0RWxlbWVudC5pbm5lckhUTUwgPSBVdGlscy5mb3JtYXRBbmdsZVN0cmluZyhwbGFuZXQuZm9ybWF0dGVkU2lnbkFuZ2xlLCB0aGlzLm9wdGlvbnMuYW5nbGVGb3JtYXQpO1xuXG4gICAgICAgICAgICAvLyBSb3RhdGUgJiBvZmZzZXQgcG9zaXRpb24gaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJvdGF0ZUFuZ2xlVGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0T2Zmc2V0ID0gYW5nbGVUZXh0RWxlbWVudC5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgdmFyIHRvcE9mZnNldCA9IGFuZ2xlVGV4dEVsZW1lbnQub2Zmc2V0SGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgICAgIGxldCByb3RhdGlvbkFuZ2xlID0gYW5nbGUgKiAtMTtcblxuICAgICAgICAgICAgICAgIGlmIChhbmdsZSA+IDkwICYmIGFuZ2xlIDwgMjcwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uQW5nbGUgLT0gMTgwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFuZ2xlVGV4dEVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHJvdGF0ZSgke3JvdGF0aW9uQW5nbGV9ZGVnKWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbcmVsWCwgcmVsWV0gPSBVdGlscy5maW5kUmVsYXRpdmVQb2ludCh0aGlzLmVsZW1lbnRzLmNoYXJ0LCBhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRPZmZzZXQgPSBhbmdsZVRleHRFbGVtZW50Lm9mZnNldFdpZHRoICogKHJlbFggLyB0aGlzLmVsZW1lbnRzLmNoYXJ0Lm9mZnNldFdpZHRoKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9wT2Zmc2V0ID0gYW5nbGVUZXh0RWxlbWVudC5vZmZzZXRIZWlnaHQgKiAocmVsWSAvIHRoaXMuZWxlbWVudHMuY2hhcnQub2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0IHBvc2l0aW9uIGJhc2VkIG9uIGNhbGN1bGF0ZWQgb2Zmc2V0c1xuICAgICAgICAgICAgbGV0IFthYnNYLCBhYnNZXSA9IFV0aWxzLmZpbmRHbG9iYWxQb2ludCh0aGlzLmVsZW1lbnRzLmNoYXJ0LCB0aGlzLmVsZW1lbnRzLmFuZ2xlVGV4dFRyYWNrLCBhbmdsZSk7XG5cbiAgICAgICAgICAgIGFic1ggPSBNYXRoLnJvdW5kKGFic1ggLSBsZWZ0T2Zmc2V0KTtcbiAgICAgICAgICAgIGFic1kgPSBNYXRoLnJvdW5kKGFic1kgLSB0b3BPZmZzZXQpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGFuZ2xlVGV4dEVsZW1lbnQuc3R5bGUsIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBhYnNYICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB0b3A6IGFic1kgKyAncHgnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIG1hcmtlcnMgZm9yIGVhY2ggcGxhbmV0J3Mgb3JpZ2luYWwgcHJlLWNvbGxpc2lvbi1jaGVjayBwbGFjZW1lbnQuXG4gICAgc2V0UGxhbmV0QW5nbGVNYXJrZXJzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtwbGFuZXROYW1lLCBwbGFuZXRdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMucGxhbmV0cykpIHtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gcGxhbmV0LmNoYXJ0QW5nbGUgLSB0aGlzLm9mZnNldEFuZ2xlO1xuICAgICAgICAgICAgY29uc3QgcGxhbmV0Q2xhc3NOYW1lID0gcGxhbmV0TmFtZS5yZXBsYWNlKCcgJywgJy0nKTtcbiAgICAgICAgICAgIGNvbnN0IFt4MSwgeTFdID0gVXRpbHMuZmluZEdsb2JhbFBvaW50KHRoaXMuZWxlbWVudHMuY2hhcnQsIHRoaXMuZWxlbWVudHMuYW5nbGVNYXJrZXJzRW5kQm91bmRhcnksIGFuZ2xlKTtcbiAgICAgICAgICAgIGNvbnN0IFt4MiwgeTJdID0gVXRpbHMuZmluZEdsb2JhbFBvaW50KHRoaXMuZWxlbWVudHMuY2hhcnQsIHRoaXMuZWxlbWVudHMuYW5nbGVNYXJrZXJzU3RhcnRCb3VuZGFyeSwgYW5nbGUpO1xuICAgICAgICAgICAgdGhpcy5kcmF3TGluZSh4MSwgeTEsIHgyLCB5MiwgJ2ltbWFudWVsX19hbmdsZS1tYXJrZXInLCBgYW5nbGUtbWFya2VyLS0ke3BsYW5ldENsYXNzTmFtZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBsaW5lcyBmcm9tIGVhY2ggYW5nbGUgbWFya2VyIHRvIHRoZSBwbGFuZXQncyBhY3R1YWwgcG9zaXRpb24uXG4gICAgc2V0UGxhbmV0QW5nbGVQb2ludGVycygpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5wbGFuZXRzLmZvckVhY2gocGxhbmV0RWxlbWVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwbGFuZXROYW1lID0gcGxhbmV0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW1tYW51ZWwtcGxhbmV0Jyk7XG4gICAgICAgICAgICBjb25zdCBwbGFuZXQgPSB0aGlzLnBsYW5ldHNbcGxhbmV0TmFtZV07XG4gICAgICAgICAgICBjb25zdCBtYXJrZXJBbmdsZSA9IHBsYW5ldC5jaGFydEFuZ2xlIC0gdGhpcy5vZmZzZXRBbmdsZTtcbiAgICAgICAgICAgIGNvbnN0IHBsYW5ldEFuZ2xlID0gcGxhbmV0LmRpc3BsYXlBbmdsZSAtIHRoaXMub2Zmc2V0QW5nbGU7XG4gICAgICAgICAgICBjb25zdCBwbGFuZXREaWFtZXRlciA9IE1hdGgubWF4KHBsYW5ldEVsZW1lbnQub2Zmc2V0V2lkdGgsIHBsYW5ldEVsZW1lbnQub2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IHBsYW5ldENsYXNzTmFtZSA9IHBsYW5ldE5hbWUucmVwbGFjZSgnICcsICctJyk7XG4gICAgICAgICAgICBjb25zdCBbeDEsIHkxXSA9IFV0aWxzLmZpbmRHbG9iYWxQb2ludCh0aGlzLmVsZW1lbnRzLmNoYXJ0LCB0aGlzLmVsZW1lbnRzLmFuZ2xlTWFya2Vyc1N0YXJ0Qm91bmRhcnksIG1hcmtlckFuZ2xlKTtcbiAgICAgICAgICAgIGNvbnN0IFt4MiwgeTJdID0gVXRpbHMuZmluZEdsb2JhbFBvaW50KHRoaXMuZWxlbWVudHMuY2hhcnQsIHRoaXMuZWxlbWVudHMucGxhbmV0VHJhY2ssIHBsYW5ldEFuZ2xlLCBwbGFuZXREaWFtZXRlciArIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IFt4MywgeTNdID0gVXRpbHMuZmluZEdsb2JhbFBvaW50KHRoaXMuZWxlbWVudHMuY2hhcnQsIHRoaXMuZWxlbWVudHMucGxhbmV0VHJhY2ssIHBsYW5ldEFuZ2xlLCBwbGFuZXREaWFtZXRlcik7XG4gICAgICAgICAgICB0aGlzLmRyYXdMaW5lKHgxLCB5MSwgeDIsIHkyLCAnaW1tYW51ZWxfX2FuZ2xlLXBvaW50ZXInLCBgYW5nbGUtcG9pbnRlci0tJHtwbGFuZXRDbGFzc05hbWV9YCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdMaW5lKHgyLCB5MiwgeDMsIHkzLCAnaW1tYW51ZWxfX2FuZ2xlLXBvaW50ZXInLCBgYW5nbGUtcG9pbnRlci0tJHtwbGFuZXRDbGFzc05hbWV9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERyYXcgdGhlIGhvdXNlIGN1c3AgbGluZXMuXG4gICAgc2V0SG91c2VzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtob3VzZU51bWJlciwgaG91c2VdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuY2hhcnREYXRhLmhvdXNlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gaG91c2UuY2hhcnRBbmdsZSAtIHRoaXMub2Zmc2V0QW5nbGU7XG4gICAgICAgICAgICBjb25zdCBbeDEsIHkxXSA9IFV0aWxzLmZpbmRHbG9iYWxQb2ludCh0aGlzLmVsZW1lbnRzLmNoYXJ0LCB0aGlzLmVsZW1lbnRzLmhvdXNlRW5kQm91bmRhcnksIGFuZ2xlKTtcbiAgICAgICAgICAgIGNvbnN0IFt4MiwgeTJdID0gVXRpbHMuZmluZEdsb2JhbFBvaW50KHRoaXMuZWxlbWVudHMuY2hhcnQsIHRoaXMuZWxlbWVudHMuaG91c2VTdGFydEJvdW5kYXJ5LCBhbmdsZSk7XG4gICAgICAgICAgICB0aGlzLmRyYXdMaW5lKHgxLCB5MSwgeDIsIHkyLCAnaW1tYW51ZWxfX2hvdXNlLWxpbmUnLCBgaG91c2UtbGluZS0tJHtob3VzZU51bWJlcn1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBob3VzZSBudW1iZXJzXG4gICAgc2V0SG91c2VOdW1iZXJzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtob3VzZU51bWJlciwgaG91c2VdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuY2hhcnREYXRhLmhvdXNlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gaG91c2UuY2hhcnRBbmdsZSAtIHRoaXMub2Zmc2V0QW5nbGU7XG4gICAgICAgICAgICBjb25zdCBuZXh0SG91c2VOdW1iZXIgPSBob3VzZU51bWJlciA9PSAxMiA/IDEgOiBwYXJzZUludChob3VzZU51bWJlcikgKyAxO1xuICAgICAgICAgICAgY29uc3QgbmV4dEhvdXNlQW5nbGUgPSB0aGlzLmNoYXJ0RGF0YS5ob3VzZXNbbmV4dEhvdXNlTnVtYmVyXS5jaGFydEFuZ2xlO1xuICAgICAgICAgICAgY29uc3QgaG91c2VXaWR0aEFuZ2xlID0gKG5leHRIb3VzZUFuZ2xlIDwgYW5nbGUgPyBuZXh0SG91c2VBbmdsZSArIDM2MCA6IG5leHRIb3VzZUFuZ2xlKSAtIGFuZ2xlO1xuICAgICAgICAgICAgY29uc3QgbWlkcG9pbnRBbmdsZSA9IGFuZ2xlICsgKGhvdXNlV2lkdGhBbmdsZSAtIHRoaXMub2Zmc2V0QW5nbGUpIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGhvdXNlTnVtYmVyRWxlbWVudCA9IHRoaXMuZWxlbWVudHMuaG91c2VOdW1iZXJzW2hvdXNlTnVtYmVyXTtcblxuICAgICAgICAgICAgbGV0IFt4LCB5XSA9IFV0aWxzLmZpbmRHbG9iYWxQb2ludCh0aGlzLmVsZW1lbnRzLmNoYXJ0LCB0aGlzLmVsZW1lbnRzLmhvdXNlTnVtYmVyVHJhY2ssIG1pZHBvaW50QW5nbGUpO1xuXG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZCh4IC0gaG91c2VOdW1iZXJFbGVtZW50Lm9mZnNldFdpZHRoIC8gMik7XG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZCh5IC0gaG91c2VOdW1iZXJFbGVtZW50Lm9mZnNldEhlaWdodCAvIDIpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGhvdXNlTnVtYmVyRWxlbWVudC5zdHlsZSwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHggKyAncHgnLFxuICAgICAgICAgICAgICAgIHRvcDogeSArICdweCcsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yb3RhdGVIb3VzZU51bWJlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3RhdGlvbkFuZ2xlID0gKG1pZHBvaW50QW5nbGUgKiAtMSkgKyA5MDtcbiAgICAgICAgICAgICAgICBob3VzZU51bWJlckVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHJvdGF0ZSgke3JvdGF0aW9uQW5nbGV9ZGVnKWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEcmF3IGFzcGVjdCBsaW5lcyBpbiB0aGUgb3JkZXIgdGhlIHR5cGVzIGFyZSBsYWlkIG91dCBpbiB0aGlzLm9wdGlvbnMuYXNwZWN0T3JkZXIuXG4gICAgc2V0QXNwZWN0cygpIHtcbiAgICAgICAgY29uc3QgYXNwZWN0c1RvRHJhdyA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMuYXNwZWN0T3JkZXIucmV2ZXJzZSgpLmZvckVhY2goYXNwZWN0VHlwZSA9PiBhc3BlY3RzVG9EcmF3W2FzcGVjdFR5cGVdID0gW10pO1xuXG4gICAgICAgIGZvciAoY29uc3QgW3BsYW5ldE5hbWUsIHBsYW5ldF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5wbGFuZXRzKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYXNwZWN0ZWRQbGFuZXROYW1lLCBhc3BlY3RdIG9mIE9iamVjdC5lbnRyaWVzKHBsYW5ldC5hc3BlY3RzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzdGFydFBsYW5ldE5hbWUsIGVuZFBsYW5ldE5hbWVdID0gW3BsYW5ldE5hbWUsIGFzcGVjdGVkUGxhbmV0TmFtZV0uc29ydCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzcGVjdFR5cGUgPSBhc3BlY3QudHlwZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBwbGFuZXQgd2UgZG9uJ3Qgd2FudCB0byBhc3BlY3QsIG9yIHRoaXMgaXMgYW4gYXNwZWN0IHdlIGRvbid0IHdhbnQsIHNraXAgaXRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXNwZWN0ZWRQbGFuZXRzLmluY2x1ZGVzKHN0YXJ0UGxhbmV0TmFtZSkgfHwgIXRoaXMuYXNwZWN0ZWRQbGFuZXRzLmluY2x1ZGVzKGVuZFBsYW5ldE5hbWUpIHx8ICF0aGlzLm9wdGlvbnMuYXNwZWN0T3JkZXIuaW5jbHVkZXMoYXNwZWN0VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgYXNwZWN0VG9EcmF3ID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiB0aGlzLnBsYW5ldHNbc3RhcnRQbGFuZXROYW1lXS5jaGFydEFuZ2xlIC0gdGhpcy5vZmZzZXRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kQW5nbGU6IHRoaXMucGxhbmV0c1tlbmRQbGFuZXROYW1lXS5jaGFydEFuZ2xlIC0gdGhpcy5vZmZzZXRBbmdsZSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgZHVwbGljYXRlc1xuICAgICAgICAgICAgICAgIGlmIChhc3BlY3RzVG9EcmF3W2FzcGVjdFR5cGVdLnNvbWUoYXNwZWN0RGF0YSA9PiBKU09OLnN0cmluZ2lmeShhc3BlY3REYXRhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYXNwZWN0VG9EcmF3KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXNwZWN0c1RvRHJhd1thc3BlY3RUeXBlXS5wdXNoKGFzcGVjdFRvRHJhdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgd2UgaGF2ZSBvdXIgZGVmaW5pdGl2ZSBsaXN0LCBkcmF3IHRoZW1cbiAgICAgICAgZm9yIChjb25zdCBbYXNwZWN0VHlwZSwgYXNwZWN0TGlzdF0gb2YgT2JqZWN0LmVudHJpZXMoYXNwZWN0c1RvRHJhdykpIHtcbiAgICAgICAgICAgIGFzcGVjdExpc3QuZm9yRWFjaChhc3BlY3QgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4MSwgeTFdID0gVXRpbHMuZmluZEdsb2JhbFBvaW50KHRoaXMuZWxlbWVudHMuY2hhcnQsIHRoaXMuZWxlbWVudHMuYXNwZWN0RW5kQm91bmRhcnksIGFzcGVjdC5zdGFydEFuZ2xlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbeDIsIHkyXSA9IFV0aWxzLmZpbmRHbG9iYWxQb2ludCh0aGlzLmVsZW1lbnRzLmNoYXJ0LCB0aGlzLmVsZW1lbnRzLmFzcGVjdEVuZEJvdW5kYXJ5LCBhc3BlY3QuZW5kQW5nbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoeDEsIHkxLCB4MiwgeTIsICdpbW1hbnVlbF9fYXNwZWN0LWxpbmUnLCBgYXNwZWN0LWxpbmUtLSR7YXNwZWN0VHlwZX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRHJhdyBhIGxpbmUgaW4gdGhlIGNoYXJ0IGJhc2VkIG9uIGNvb3JkaW5hdGVzLCBhbmQgYWRkIGNsYXNzZXMuXG4gICAgZHJhd0xpbmUoeDEsIHkxLCB4MiwgeTIsIC4uLmNsYXNzTGlzdCkge1xuICAgICAgICBjb25zdCBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdsaW5lJyk7XG4gICAgICAgIGxpbmUuY2xhc3NMaXN0LmFkZCguLi5jbGFzc0xpc3QpO1xuICAgICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4MScsIHgxKTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneTEnLCB5MSk7XG4gICAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gyJywgeDIpO1xuICAgICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5MicsIHkyKTtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5jaGFydFN2Zy5hcHBlbmRDaGlsZChsaW5lKTtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5jaGFydExpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuXG59IiwiaW1wb3J0IE9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCBFbGVtZW50cyBmcm9tICcuL2VsZW1lbnRzJztcbmltcG9ydCBDaGFydCBmcm9tICcuL2NoYXJ0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW1tYW51ZWwge1xuXG4gICAgY29uc3RydWN0b3Ioc2VsZWN0b3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gRWxlbWVudHMuY3JlYXRlKHNlbGVjdG9yKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT3B0aW9ucy5jcmVhdGUob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZGlzcGxheUNoYXJ0KGNoYXJ0RGF0YSkge1xuICAgICAgICBDaGFydC5jcmVhdGUodGhpcy5lbGVtZW50cywgdGhpcy5vcHRpb25zLCBjaGFydERhdGEpLmRpc3BsYXkoKTtcbiAgICB9XG5cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///676\n")})();